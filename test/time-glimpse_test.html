<!-- 
  http://127.0.0.1:8081/components/time-glimpse/test/
-->

<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">

    <title>time-glimpse test</title>

    <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
    <script src="../../web-component-tester/browser.js"></script>

    <link rel="import" href="../time-glimpse.html">
  </head>
  <body>

    <test-fixture id="BasicTestFixture">
      <template>
        <time-glimpse></time-glimpse>
      </template>
    </test-fixture>

    <test-fixture id="ChangedPropertyTestFixture">
      <template>
        <time-glimpse prop1="new-prop1"></time-glimpse>
      </template>
    </test-fixture>

    <script>
      describe( 'wrong parameters', () => {
        let element;

        before( () => {
          element = fixture('BasicTestFixture');
          element.set('datetimes', { unexpectedKey: 'unexpectedValue' });
        });
    
        it( 'pass wrongly formatted data behaves properly', () => {
          expect( element.timelineData,  `datetimes wrongly formatted` ).to.equal  ( undefined );
        });
      });

      describe( 'setup', () => {
        let element;
        let firstDate;

        before( () => {
          const datetimes = [
            '2017-08-11T14:17:00-0300',
            '2017-08-07T16:00:00-0300',
            '2017-08-23T15:22:00-0300',
            '2017-09-01T16:34:00-0300',
            '2017-08-17T15:22:00-0300',
            '2017-09-21T17:44:00-0300',
            '2017-09-13T14:48:00-0300',
          ];
          element = fixture('BasicTestFixture');
          element.set('datetimes', datetimes);
          firstDate = element.timelineData[0];
        });
    
        it( 'instantiating the element with correct data works', () => {
          expect( element.datetimes[0],  `first datetime` ).to.equal  ( '2017-08-11T14:17:00-0300' );
        });

        it( 'datetime is correctly passed', () => {
          // console.log(firstDate);
          const noTimeDate = firstDate.datetime.toString().split('2017')[0].trim();
          expect( `${noTimeDate}`,  `firstDate` ).to.equal  ( 'Fri Aug 11' );
        });

        it( 'weekday is properly calculated', () => expect( `${firstDate.weekday}` )      .to.equal  ( 'fri'              ) );
        it( 'time is properly calculated',    () => expect( `${firstDate.time}` )         .to.equal  ( '14:17'            ) );
        it( 'date is properly calculated',    () => expect( `${firstDate.date}` )         .to.equal  ( '08/11/2017'       ) );
        it( 'formatted date is calculated',   () => expect( `${firstDate.formattedDate}` ).to.equal  ( 'August 11, 2017'  ) );

      });

      describe( 'outliers', () => {
        let element;
        let td, expectedDateOutlier, expectedTimeOutlier;

        before( () => {
          const datetimes = [ 
            "2016-02-11T02:00:00.000Z", 
            "2017-03-11T19:48:59.000Z", 
            "2017-02-12T02:00:00.000Z", 
            "2017-02-20T03:00:00.000Z", 
            "2017-03-23T04:00:00.000Z", 
            "2017-04-02T06:00:00.000Z", 
            "2017-04-09T03:00:00.000Z", 
            "2017-05-28T06:00:00.000Z", 
            "2017-07-01T04:59:59.000Z", 
            "2017-08-16T04:30:00.000Z", 
            "2017-09-03T03:00:00.000Z", 
            "2017-09-10T03:00:00.000Z" 
          ];

          element = fixture('BasicTestFixture');
          element.set('datetimes', datetimes);
          td = element.timelineData;
          expectedDateOutlier = td[0]; 
          expectedTimeOutlier = td[1];
        });
        
        it( 'date outlier is annotated as generic outlier', () => {
          expect( expectedDateOutlier.isOutlier,  `date outlier is annotated as generic outlier` ).to.equal  ( true );
        });

        it( 'date outlier is annotated specifically as date outlier', () => {
          expect( expectedDateOutlier.dateValIsOutlier,  `date outlier is annotated specifically as date outlier` ).to.equal  ( true );
        });

        it( 'time outlier is annotated as generic outlier', () => {
          expect( expectedTimeOutlier.isOutlier,  `time outlier is annotated as generic outlier` ).to.equal  ( true );
        });

        it( 'time outlier is annotated specifically as time outlier', () => {
          expect( expectedTimeOutlier.timeValIsOutlier,  `time outlier is annotated specifically as time outlier` ).to.equal  ( true );
        });

        it( 'no outliers in small datasets', () => {
          const datetimes = [ 
            "2016-02-11T02:00:00.000Z", 
            "2017-03-11T19:48:59.000Z", 
            "2017-02-12T02:00:00.000Z", 
            "2017-02-20T03:00:00.000Z", 
          ];

          // element = fixture('BasicTestFixture');
          element.set('datetimes', datetimes);
          td = element.timelineData;
          expect( td[0].isOutlier,  `no outlier` ).to.not.equal  ( true );
        });

      });
    </script>

  </body>
</html>
